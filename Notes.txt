
// npm create vite@latest

//ğŸŒHooks
ğŸ“‹ Hooks are functions to use some react features in functional components
ğŸ“‹ Hooks are functions that make functional components work like class components



ğŸ”useState ->  useState hook is used to add state in functional components. 
ğŸ“‹ state is nothing but just values or variables of your component
ğŸ“‹ It returns an array with the current state value and a function to update that value.
ğŸ“‹ Updating state with useState involves calling the function returned by the hook and passing the new value.
ğŸ“‹ Array destructuring can be used to simplify the code.
ğŸ“‹ useState can handle different types of data (boolean, number, text, object, array).




ğŸ”useEffect
ğŸ“‹ useEffect is used to perform side effect in our component
ğŸ“‹ side effects are actions which are performed with the outside world
ğŸ“‹ We perform a side effect when we need to reach outside of our React components to do something

ğŸ“‹ useEffect is used for side effects in components, such as fetching data from API, updating the DOM and window, or using timers, setTimeout and setIntervals.
It combines componentDidMount, componentDidUpdate, and componentWillUnmount.

ğŸ“‹ useEffect(callback, dependencies)
ğŸ“‹ callback-> function (side effect logic) = what to run
ğŸ“‹ dependencies-> Array of variables  = when to run
ğŸ“‹ useEffect runs on every render, which means when the count changes render happens and we can control that by dependencies

ğŸ“‹ useEffect has three variations:- 
    without dependencies (runs on every change), 
    with an empty array (runs once on mount), when our component gets render first time => it is useful when we fetch data from API or server, that will fetch data when the component gets render first time
    and with variables (runs on mount and when specified variables change).

ğŸ“‹ Cleanup functions in useEffect are essential to handle scenarios where side effects need to be stopped or cleaned up, preventing performance issues.




ğŸ”useContext
ğŸ“‹ useContext hook is used to manage global data in react application, like Global state, Themes, Services, User Settings
ğŸ“‹ useContext will help us to create global data for our react application and we don't have to pass the data through all the components 
we can access the data in all component whenever we need it 
ğŸ“‹ if you want to pass data just for child component, then you can use props

ğŸ“‹ create context require three steps:
    1) Creating the context (using createContext()) 
    2) Providing the context  (u need to decide which components can access this context with the use of context.provider)
    3) Consuming the context  (import that context and pass that context inside useContext() hook)



ğŸ”useRef
ğŸ“‹useRef is allow us to create mutable variables which will not re-render the component
ğŸ“‹useRef allows us to direct access DOM elements without writing  Document.getElementById/className by ref attribute

ğŸ“‹const variableName = useRef(initialVlaue) 



ğŸ”useReducer
ğŸ“‹useReducer is used to manage complex state in our react application
ğŸ“‹useReducer works like a state management tool
ğŸ“‹state management is used to manage all states of application in a simple way 
ğŸ“‹Always use the useReducer hook when you have a lot of states and methods to handle
ğŸ“‹it returns an array same as useState
ğŸ“‹useReducer accepts two arguments first is reducer function in which we write out all logic and second is default/initial State
ğŸ“‹reducer function takes two parameters first is state second is action 



ğŸ”useLayoutEffect
ğŸ“‹useLayoutEffect works exactly the same as useEffect but the differece is "when it runs"
ğŸ“‹useEffect runs after the DOM is printed on the browser
ğŸ“‹useLayoutEffect runs before the DOM is printed on the browser 
ğŸ“‹whenever we want to  run code before the DOM is printed like we want to measure an element's height, width 
or anything related to layout we can use useLayoutEffect
ğŸ“‹it runs synchronously which means it runs the first line and only move to the if first line's execution is completed
ğŸ“‹The most common use case of useLayoutEffect is to get the dimension of the layout

ğŸ“‹work flow:-
ğŸ“‹React calculates all it's mutations 
ğŸ“‹Then useLayoutEffect will run 
ğŸ“‹Then react prints all elements on DOM
ğŸ“‹Then useEffect will run



ğŸ”useMemo
ğŸ“‹useMemo hook is used to apply Memoization in React
ğŸ“‹Memoization is a technique for improving the performance of code 
ğŸ“‹It is useful to avoid expensive calculations on every render when the returned value is not going to changed.
ğŸ“‹useMemo syntax is same as useEffect

ğŸ“‹ useEffect vs useMemo
ğŸ“‹In useEffect we can't return the value and we can't store it in variable we have to create one more state variable 
then with setValue funtion we can update that 
ğŸ“‹But in UseMemo we can return the value and we can store this value in a variable
ğŸ“‹we perform all side effects in useEffect hook
ğŸ“‹All expensive functions, calculations in useMemo hook

ğŸ“‹it is used to improve performance of our react application
ğŸ“‹we can stop running unwanted functions on Re-rendering




ğŸ”useCallback
ğŸ“‹useCallback is used to return Memoize function
ğŸ“‹it is also useful for preventing functions from being re-created on re-rendering
ğŸ“‹it is similar as useMemo hook, we can't pass parameter
ğŸ“‹useMemo returns the Memoized value, we can pass parameter
ğŸ“‹useCallback returns the Memoized function
ğŸ“‹it accepts two parameter 1st is callback and 2nd is dependencies array




ğŸ”Custom Hooks
ğŸ“‹Custom Hooks are basically reusable functions 
ğŸ“‹Custom Hooks are your own hooks that you create for your own use, and you can use them multiple times in your project
ğŸ“‹instead of writing the long code in every place you create your own hook and you use it like other built in hooks
ğŸ“‹we can use multiple hooks and create something that will help you to skip repeated tasks in your projects 
ğŸ“‹
ğŸ“‹
ğŸ“‹
ğŸ“‹
ğŸ“‹
ğŸ“‹
















 ğŸ“‹ ğŸ”  âš¡ 
